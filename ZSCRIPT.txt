version "4.0"

#include "ZSCRIPT.WeaponUpgrades.zsc"

class HDWeaponUpgradeKit : HDWeapon
{
	enum KitProperties
	{
		KProp_Durability,
		KProp_SelectedWeapon,
		KProp_SelectedUpgrade
	}

	override void BeginPlay()
	{
		Super.BeginPlay();

		for (int i = 0; i < AllClasses.Size(); ++i)
		{
			if (AllClasses[i] is "WUK_WeaponUpgrade" && AllClasses[i].GetClassName() != 'WUK_WeaponUpgrade')
			{
				WUK_WeaponUpgrade Upgrade = WUK_WeaponUpgrade(new(AllClasses[i]));
				class<HDWeapon> wpn = Upgrade.GetWeapon();
				if (wpn)
				{
					AllUpgrades.Push(Upgrade);
				}
			}
		}
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Upgrade weapon\n"
		..WEPHELP_ALTFIRE.."  Downgrade weapon\n"
		..WEPHELP_ZOOM.."+"..WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Cycle weapons\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Cycle upgrades\n";
	}
	override string, double GetPickupSprite(){ return WeaponStatus[KProp_Durability] > 0 ? "WUKTA0" : "WUKTB0", 1.0; }
	override double GunMass() { return 0; }
	override double WeaponBulk() { return 40 * Amount; }
	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override void InitializeWepStats(bool idfa) { WeaponStatus[KProp_Durability] = MaxDurability; }
	override void LoadoutConfigure(string input) { WeaponStatus[KProp_Durability] = MaxDurability; }

	private void ResetConfirmation()
	{
		for (int i = 0; i < Confirmation.Size(); ++i)
		{
			Confirmation[i] = false;
		}
	}

	private action void A_UpdateAvailableWeapons()
	{
		invoker.AvailableWeapons.Clear();
		for (int i = 0; i < invoker.AllUpgrades.Size(); ++i)
		{
			HDWeapon wpn = HDWeapon(FindInventory(invoker.AllUpgrades[i].GetWeapon()));
			if (wpn && invoker.AvailableWeapons.Find(wpn) == invoker.AvailableWeapons.Size())
			{
				invoker.AvailableWeapons.Push(wpn);
			}
		}
	}

	private action void A_UpdateUpgradesForWeapon(HDWeapon wpn)
	{
		if (!wpn)
		{
			return;
		}

		invoker.CurrWeaponUpgrades.Clear();
		for (int i = 0; i < invoker.AllUpgrades.Size(); ++i)
		{
			if (invoker.AllUpgrades[i].GetWeapon() == wpn.GetClass())
			{
				invoker.CurrWeaponUpgrades.Push(invoker.AllUpgrades[i]);
			}
		}
	}

	private clearscope HDWeapon GetSelectedWeapon()
	{
		int Size = AvailableWeapons.Size();
		int SelIndex = WeaponStatus[KProp_SelectedWeapon];
		if (Size > 0 && SelIndex < Size)
		{
			return AvailableWeapons[SelIndex];
		}

		return null;
	}

	private clearscope WUK_WeaponUpgrade GetSelectedUpgrade()
	{
		int Size = CurrWeaponUpgrades.Size();
		int SelIndex = WeaponStatus[KProp_SelectedUpgrade];
		if (Size > 0 && SelIndex < Size)
		{
			return CurrWeaponUpgrades[SelIndex];
		}

		return null;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		sb.DrawRect(-41, -17, 4, 5); // Stock.
		sb.DrawRect(-34, -16, 3, 5); // Handle.
		sb.DrawRect(-28, -16, 5, 5); // Magazine.
		sb.DrawRect(-37, -17, 19, 3); // Body.
		sb.DrawRect(-32, -20, 11, 3); // Scope.
		sb.DrawRect(-18, -17, 6, 1); // Barrel.

		sb.DrawWepNum(hdw.WeaponStatus[KProp_Durability], MaxDurability);

		vector2 bob = hpl.hudbob * 0.3;
		int BaseYOffset = -50;
		
		sb.DrawImage(GetPickupSprite(), (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER_BOTTOM, 1.0, scale:(2, 2));

		let SelWeapon = GetSelectedWeapon();
		if (SelWeapon)
		{
			sb.DrawImage(SelWeapon.GetPickupSprite(), (0, BaseYOffset - 160) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, alpha: 1.0);
			sb.DrawString(sb.pSmallFont, SelWeapon.GetTag(), (0, BaseYOffset - 140) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_SAPPHIRE, 1.0);

			int Size = CurrWeaponUpgrades.Size();
			for (int i = 0; i < Size; ++i)
			{
				bool Selected = i == hdw.WeaponStatus[KProp_SelectedUpgrade];
				bool CanDowngrade = CurrWeaponUpgrades[i].CanDowngrade();
				string InstalledString = CurrWeaponUpgrades[i].HasUpgrade(SelWeapon) ? " \c[Green](Installed)\c-" : " \c[Red](Not installed)\c-";
				string DisplayString = CurrWeaponUpgrades[i].GetDisplayName().."\c-"..InstalledString;
				int StringCol = Selected ? (CanDowngrade ? Font.CR_ORANGE : Font.CR_WHITE) : (CanDowngrade ? Font.FindFontColor("WUK_Downgradeable") : Font.CR_DARKGRAY);
				sb.DrawString(sb.pSmallFont, DisplayString, (0, BaseYOffset - (130 - 10 * i)) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, StringCol);

				if (Selected)
				{
					sb.DrawString(sb.pSmallFont, "Cost: "..CurrWeaponUpgrades[i].GetCost(), (0, BaseYOffset - (120 - 10 * Size)) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_TAN);
				}
			}

			string ConfirmString = "";
			if (Confirmation[0])
			{
				ConfirmString = "Confirm upgrade?";
			}
			else if (Confirmation[1])
			{
				ConfirmString = "Confirm downgrade?";
			}

			if (ConfirmString != "")
			{
				sb.DrawString(sb.pSmallFont, ConfirmString, (0, BaseYOffset - 60) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN, 1.0);
			}
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "No available weapons.", (0, BaseYOffset - 60) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_ORANGE, 1.0);
		}
	}

	private action void A_CheckWeaponCycle(int cycleDir)
	{
		A_UpdateAvailableWeapons();
		int Size = invoker.AvailableWeapons.Size();
		if (Size < 1)
		{
			return;
		}

		int SelIndex = invoker.WeaponStatus[KProp_SelectedWeapon];
		switch (cycleDir)
		{
			case 1:
				++SelIndex %= Size;
				break;
			case -1:
				SelIndex = SelIndex == 0 ? invoker.AvailableWeapons.Size() - 1 : SelIndex - 1;
				break;
		}
		invoker.WeaponStatus[KProp_SelectedWeapon] = SelIndex;
		invoker.WeaponStatus[KProp_SelectedUpgrade] = 0;
		A_UpdateUpgradesForWeapon(invoker.GetSelectedWeapon());
		invoker.ResetConfirmation();
	}

	private action void A_CheckUpgradeCycle(int cycleDir)
	{
		int Size = invoker.CurrWeaponUpgrades.Size();
		if (Size < 1)
		{
			return;
		}

		int SelIndex = invoker.WeaponStatus[KProp_SelectedUpgrade];
		switch (cycleDir)
		{
			case 1:
				++SelIndex %= Size;
				break;
			case -1:
				SelIndex = SelIndex == 0 ? invoker.CurrWeaponUpgrades.Size() - 1 : SelIndex - 1;
				break;
		}
		invoker.WeaponStatus[KProp_SelectedUpgrade] = SelIndex;
		invoker.ResetConfirmation();
	}

	private action void A_PerformKitAction(int act)
	{
		HDWeapon SelWeapon = invoker.GetSelectedWeapon();
		if (!SelWeapon) // [Ace] Lack of parentheses for the OR is intentional. Don't "fix" it again, you dolt.
		{
			return;
		}

		WUK_WeaponUpgrade Upgrade = invoker.GetSelectedUpgrade();
		if (!Upgrade)
		{
			return;
		}

		if (act == 0 && Upgrade.HasUpgrade(SelWeapon))
		{
			A_WeaponMessage("Upgrade has already been installed.");
			return;
		}

		if (act == 1 && (!Upgrade.HasUpgrade(SelWeapon) || !Upgrade.CanDowngrade()))
		{
			A_WeaponMessage("Upgrade has already been uninstalled or no downgrade is available.");
			return;
		}

		if (invoker.WeaponStatus[KProp_Durability] < Upgrade.GetCost())
		{
			A_WeaponMessage("Insufficient durability.");
			return;
		}

		if (invoker.Confirmation[act])
		{
			switch (act)
			{
				case 0: Upgrade.DoUpgrade(SelWeapon); break;
				case 1: Upgrade.DoDowngrade(SelWeapon); break;
			}
			A_PlaySound("WUKit/InstallUpgrade", 10);
			invoker.WeaponStatus[KProp_Durability] -= Upgrade.GetCost();
			invoker.ResetConfirmation();
			if (invoker.WeaponStatus[KProp_Durability] == 0)
			{
				DropInventory(invoker);
			}
		}
		else
		{
			invoker.Confirmation[act] = true;
		}
		
	}

	const MaxDurability = 2;
	bool Confirmation[2];
	private Array<WUK_WeaponUpgrade> AllUpgrades;
	private Array<HDWeapon> AvailableWeapons;
	private Array<WUK_WeaponUpgrade> CurrWeaponUpgrades;

	Default
	{
		+WEAPON.WIMPY_WEAPON
		+INVENTORY.INVBAR
		+HDWEAPON.FITSINBACKPACK
		Inventory.PickupSound "weapons/pocket";
		Inventory.PickupMessage "Picked up a weapon upgrade kit.";
		Scale 0.6;
		HDWeapon.RefId "wuk";
		Tag "Weapon upgrade kit";
	}

	States
	{
		Spawn:
			WUKT A -1 NoDelay
			{
				frame = invoker.WeaponStatus[KProp_Durability] > 0 ? 0 : 1;
			}
			Stop;
		Select0:
			TNT1 A 0
			{
				invoker.ResetConfirmation();
				invoker.WeaponStatus[KProp_SelectedUpgrade] = 0;
				A_UpdateAvailableWeapons();
				A_UpdateUpgradesForWeapon(invoker.GetSelectedWeapon());
				A_Raise(999);
			}
			Wait;
		Deselect0:
			TNT1 A 0 A_Lower(999);
			Wait;
		Fire:
			TNT1 A 5
			{
				if (PressingZoom())
				{
					A_CheckWeaponCycle(1);
				}
				else if (PressingFiremode())
				{
					A_CheckUpgradeCycle(1);
				}
				else
				{
					A_PerformKitAction(0);
				}
			}
			Goto Ready;
		AltFire:
			TNT1 A 5
			{
				if (PressingZoom())
				{
					A_CheckWeaponCycle(-1);
				}
				else if (PressingFiremode())
				{
					A_CheckUpgradeCycle(-1);
				}
				else
				{
					A_PerformKitAction(1);
				}
			}
			Goto Ready;
		Ready:
			TNT1 A 1 A_WeaponReady(WRF_ALLOWUSER3);
			Goto ReadyEnd;
		User3:
			#### A 0 A_SelectWeapon("PickupManager");
			Goto Ready;
	}
}