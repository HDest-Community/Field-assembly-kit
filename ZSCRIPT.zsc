version "4.7"

#include "ZSCRIPT.Upgrades.Thinker.zsc"
#include "ZSCRIPT.Upgrades.Vanilla.zsc"
#include "ZSCRIPT.Upgrades.AceCorp.zsc"
#include "ZSCRIPT.Upgrades.Icarus.zsc"
#include "ZSCRIPT.Upgrades.Peppergrinder.zsc"
#include "ZSCRIPT.Upgrades.Hoagietech.zsc"
#include "ZSCRIPT.Upgrades.HexaDoken.zsc"
#include "ZSCRIPT.Upgrades.Potetobloke.zsc"
#include "ZSCRIPT.Upgrades.Mohl.zsc"

class WUK_Handler : EventHandler
{
	override void PlayerEntered(PlayerEvent e)
	{
		WUK_UpgradeThinker thonker = new('WUK_UpgradeThinker');
		thonker.PlayerNumber = e.PlayerNumber;
	}
}

class WUK_WeaponUpgrade abstract
{
	enum FailMessageType
	{
		FMType_Requirements,
		FMType_Installed,
		FMType_Uninstalled,
		FMType_NotAvailable
	}

	abstract string GetWeapon();
	abstract string GetDisplayName();
	virtual int GetCost() const { return 2; }

	abstract play void DoUpgrade(HDWeapon wpn);
	abstract int HasUpgrade(HDWeapon wpn) const;

	virtual play void DoDowngrade(HDWeapon wpn) { }
	virtual bool CanDowngrade() const { return false; }

	virtual string GetConflictingUpgrade(HDWeapon wpn) const { return ""; }

	virtual bool CheckPrerequisites(HDWeapon wpn) const { return true; }
	virtual string GetFailMessage(HDWeapon wpn, int type) const
	{
		switch (type)
		{
			case FMType_Requirements: return "Requirements not met.";
			case FMType_Installed: return "Upgrade has already been installed.";
			case FMType_Uninstalled: return "Upgrade has already been uninstalled.";
			case FMType_NotAvailable: return "Downgrade not available.";
		}
		return "Error message that the player should never see. Go complain to Ace.";
	}
}

class HDWeaponUpgradeKit : HDWeapon
{
	enum KitProperties
	{
		KProp_Durability,
		KProp_SelectedWeapon,
		KProp_SelectedUpgrade
	}

	override void BeginPlay()
	{
		Super.BeginPlay();

		for (int i = 0; i < AllClasses.Size(); ++i)
		{
			if (AllClasses[i] is 'WUK_WeaponUpgrade' && !AllClasses[i].IsAbstract())
			{
				WUK_WeaponUpgrade Upgrade = WUK_WeaponUpgrade(new(AllClasses[i]));
				class<HDWeapon> wpn = Upgrade.GetWeapon();
				if (wpn)
				{
					AllUpgrades.Push(Upgrade);
				}
			}
		}
	}

	override string GetHelpText()
	{
		return WEPHELP_FIRE.."  Upgrade weapon\n"
		..WEPHELP_ALTFIRE.."  Downgrade weapon\n"
		..WEPHELP_ZOOM.."+"..WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Cycle weapons\n"
		..WEPHELP_FIREMODE.."+"..WEPHELP_FIRE.."/"..WEPHELP_ALTFIRE.."  Cycle upgrades\n";
	}
	override string, double GetPickupSprite(){ return WeaponStatus[KProp_Durability] > 0 ? "WUKTA0" : "WUKTB0", 1.0; }
	override double GunMass() { return 0; }
	override double WeaponBulk() { return 40 * Amount; }
	override bool AddSpareWeapon(actor newowner) { return AddSpareWeaponRegular(newowner); }
	override HDWeapon GetSpareWeapon(actor newowner, bool reverse, bool doselect) { return GetSpareWeaponRegular(newowner, reverse, doselect); }
	override void InitializeWepStats(bool idfa) { WeaponStatus[KProp_Durability] = MaxDurability; }
	override void LoadoutConfigure(string input) { WeaponStatus[KProp_Durability] = MaxDurability; }

	private void ResetConfirmation()
	{
		for (int i = 0; i < Confirmation.Size(); ++i)
		{
			Confirmation[i] = false;
		}
	}

	private action void A_UpdateAvailableWeapons()
	{
		invoker.AvailableWeapons.Clear();
		for (int i = 0; i < invoker.AllUpgrades.Size(); ++i)
		{
			HDWeapon wpn = HDWeapon(FindInventory(invoker.AllUpgrades[i].GetWeapon()));
			if (wpn && invoker.AvailableWeapons.Find(wpn) == invoker.AvailableWeapons.Size())
			{
				invoker.AvailableWeapons.Push(wpn);
			}
		}
	}

	private action void A_UpdateUpgradesForWeapon(HDWeapon wpn)
	{
		if (!wpn)
		{
			return;
		}

		invoker.CurrWeaponUpgrades.Clear();
		for (int i = 0; i < invoker.AllUpgrades.Size(); ++i)
		{
			if (invoker.AllUpgrades[i].GetWeapon() == wpn.GetClass())
			{
				invoker.CurrWeaponUpgrades.Push(invoker.AllUpgrades[i]);
			}
		}
	}

	private clearscope HDWeapon GetSelectedWeapon()
	{
		int Size = AvailableWeapons.Size();
		int SelIndex = WeaponStatus[KProp_SelectedWeapon];
		if (Size > 0 && SelIndex < Size)
		{
			return AvailableWeapons[SelIndex];
		}

		return null;
	}

	private clearscope WUK_WeaponUpgrade GetSelectedUpgrade()
	{
		int Size = CurrWeaponUpgrades.Size();
		int SelIndex = WeaponStatus[KProp_SelectedUpgrade];
		if (Size > 0 && SelIndex < Size)
		{
			return CurrWeaponUpgrades[SelIndex];
		}

		return null;
	}

	override void DrawHUDStuff(HDStatusBar sb, HDWeapon hdw, HDPlayerPawn hpl)
	{
		sb.DrawRect(-41, -17, 4, 5); // Stock.
		sb.DrawRect(-34, -16, 3, 5); // Handle.
		sb.DrawRect(-28, -16, 5, 5); // Magazine.
		sb.DrawRect(-37, -17, 19, 3); // Body.
		sb.DrawRect(-32, -20, 11, 3); // Scope.
		sb.DrawRect(-18, -17, 6, 1); // Barrel.

		sb.DrawWepNum(hdw.WeaponStatus[KProp_Durability], MaxDurability);

		vector2 bob = hpl.hudbob * 0.3;
		int BaseYOffset = -40;
		
		sb.DrawImage(GetPickupSprite(), (0, BaseYOffset) + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER_BOTTOM, 1.0, scale:(2, 2));

		vector2 pos = (0, BaseYOffset - 160);
		let selWeapon = GetSelectedWeapon();
		if (selWeapon)
		{
			string img = selWeapon.GetPickupSprite();
			sb.DrawImage(img, pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_ITEM_CENTER, box: (80, 20));
			pos.y += 20;
			sb.DrawString(sb.pSmallFont, selWeapon.GetTag(), pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_SAPPHIRE);
			pos.y += 10;

			int Size = CurrWeaponUpgrades.Size();
			for (int i = 0; i < Size; ++i)
			{
				bool selected = i == hdw.WeaponStatus[KProp_SelectedUpgrade];
				bool canDowngrade = CurrWeaponUpgrades[i].CanDowngrade();

				string hasUpStr = " \c[Red](Not installed)\c-";
				switch (CurrWeaponUpgrades[i].HasUpgrade(selWeapon))
				{
					case 1: hasUpStr = " \c[Green](Installed)\c-"; break;
					case 2: hasUpStr = " \c[Purple](Repeatable)\c-"; break;
				}

				string costStr = "\c[Gold]("..CurrWeaponUpgrades[i].GetCost()..")\c-";
				string fullstr = costStr.." "..CurrWeaponUpgrades[i].GetDisplayName().."\c-"..hasUpStr;
				int StringCol = selected ? (canDowngrade ? Font.CR_ORANGE : Font.CR_WHITE) : (canDowngrade ? Font.FindFontColor("WUK_Downgradeable") : Font.CR_DARKGRAY);
				sb.DrawString(sb.pSmallFont, fullstr, pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, StringCol);
				pos.y += 10;
			}

			string str = "";
			if (Confirmation[0])
			{
				str = "Confirm upgrade?";
			}
			else if (Confirmation[1])
			{
				str = "Confirm downgrade?";
			}

			if (str != "")
			{
				pos.y += 10;
				sb.DrawString(sb.pSmallFont, str, pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_GREEN);

				string conflict = GetSelectedUpgrade().GetConflictingUpgrade(selWeapon);
				if (conflict != "")
				{
					pos.y += 10;
					sb.DrawString(sb.pSmallFont, "This will remove "..conflict.."!", pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_FIRE);
				}
			}
		}
		else
		{
			sb.DrawString(sb.pSmallFont, "No available weapons.", pos + bob, sb.DI_SCREEN_CENTER_BOTTOM | sb.DI_TEXT_ALIGN_CENTER, Font.CR_ORANGE, 1.0);
		}
	}

	private action void A_CheckWeaponCycle(int cycleDir)
	{
		A_UpdateAvailableWeapons();
		int Size = invoker.AvailableWeapons.Size();
		if (Size < 1)
		{
			return;
		}

		int SelIndex = invoker.WeaponStatus[KProp_SelectedWeapon];
		switch (cycleDir)
		{
			case 1:
				++SelIndex %= Size;
				break;
			case -1:
				SelIndex = SelIndex == 0 ? invoker.AvailableWeapons.Size() - 1 : SelIndex - 1;
				break;
		}
		invoker.WeaponStatus[KProp_SelectedWeapon] = SelIndex;
		invoker.WeaponStatus[KProp_SelectedUpgrade] = 0;
		A_UpdateUpgradesForWeapon(invoker.GetSelectedWeapon());
		invoker.ResetConfirmation();
	}

	private action void A_CheckUpgradeCycle(int cycleDir)
	{
		int Size = invoker.CurrWeaponUpgrades.Size();
		if (Size < 1)
		{
			return;
		}

		int SelIndex = invoker.WeaponStatus[KProp_SelectedUpgrade];
		switch (cycleDir)
		{
			case 1:
				++SelIndex %= Size;
				break;
			case -1:
				SelIndex = SelIndex == 0 ? invoker.CurrWeaponUpgrades.Size() - 1 : SelIndex - 1;
				break;
		}
		invoker.WeaponStatus[KProp_SelectedUpgrade] = SelIndex;
		invoker.ResetConfirmation();
	}

	private action void A_PerformKitAction(int act)
	{
		HDWeapon wpn = invoker.GetSelectedWeapon();
		if (!wpn)
		{
			return;
		}

		WUK_WeaponUpgrade upgrade = invoker.GetSelectedUpgrade();
		if (!upgrade)
		{
			return;
		}

		if (act == 0)
		{
			if (upgrade.HasUpgrade(wpn) == 1)
			{
				A_WeaponMessage(upgrade.GetFailMessage(wpn, WUK_WeaponUpgrade.FMType_Installed));
				return;
			}
			if (!upgrade.CheckPrerequisites(wpn))
			{
				A_WeaponMessage(upgrade.GetFailMessage(wpn, WUK_WeaponUpgrade.FMType_Requirements));
				return;
			}
		}
		else if (act == 1)
		{
			if (!upgrade.CanDowngrade())
			{
				A_WeaponMessage(upgrade.GetFailMessage(wpn, WUK_WeaponUpgrade.FMType_NotAvailable));
				return;
			}
			if (upgrade.HasUpgrade(wpn) == 0)
			{
				A_WeaponMessage(upgrade.GetFailMessage(wpn, WUK_WeaponUpgrade.FMType_Uninstalled));
				return;
			}
		}

		if (invoker.WeaponStatus[KProp_Durability] < upgrade.GetCost())
		{
			A_WeaponMessage("Insufficient durability.");
			return;
		}

		if (invoker.Confirmation[act])
		{
			switch (act)
			{
				case 0: upgrade.DoUpgrade(wpn); break;
				case 1: upgrade.DoDowngrade(wpn); break;
			}
			A_PlaySound("WUKit/InstallUpgrade", 10);
			invoker.WeaponStatus[KProp_Durability] -= upgrade.GetCost();
			invoker.ResetConfirmation();
			if (invoker.WeaponStatus[KProp_Durability] == 0)
			{
				DropInventory(invoker);
			}
		}
		else
		{
			invoker.Confirmation[act] = true;
		}
		
	}

	const MaxDurability = 2;
	bool Confirmation[2];
	private Array<WUK_WeaponUpgrade> AllUpgrades;
	private Array<HDWeapon> AvailableWeapons;
	private Array<WUK_WeaponUpgrade> CurrWeaponUpgrades;

	Default
	{
		+WEAPON.WIMPY_WEAPON
		+INVENTORY.INVBAR
		+HDWEAPON.FITSINBACKPACK
		Inventory.PickupSound "weapons/pocket";
		Inventory.PickupMessage "Picked up a weapon upgrade kit.";
		Scale 0.6;
		HDWeapon.RefId "wuk";
		Tag "Weapon upgrade kit";
	}

	States
	{
		Spawn:
			WUKT A -1 NoDelay
			{
				frame = invoker.WeaponStatus[KProp_Durability] > 0 ? 0 : 1;
			}
			Stop;
		Select0:
			TNT1 A 0
			{
				invoker.ResetConfirmation();
				invoker.WeaponStatus[KProp_SelectedUpgrade] = 0;
				A_UpdateAvailableWeapons();
				A_UpdateUpgradesForWeapon(invoker.GetSelectedWeapon());
				A_Raise(999);
			}
			Wait;
		Deselect0:
			TNT1 A 0 A_Lower(999);
			Wait;
		Fire:
			TNT1 A 5
			{
				if (PressingZoom())
				{
					A_CheckWeaponCycle(1);
				}
				else if (PressingFiremode())
				{
					A_CheckUpgradeCycle(1);
				}
				else
				{
					A_PerformKitAction(0);
				}
			}
			Goto Ready;
		AltFire:
			TNT1 A 5
			{
				if (PressingZoom())
				{
					A_CheckWeaponCycle(-1);
				}
				else if (PressingFiremode())
				{
					A_CheckUpgradeCycle(-1);
				}
				else
				{
					A_PerformKitAction(1);
				}
			}
			Goto Ready;
		Ready:
			TNT1 A 1 A_WeaponReady(WRF_ALLOWUSER3);
			Goto ReadyEnd;
		User3:
			#### A 0 A_SelectWeapon("PickupManager");
			Goto Ready;
	}
}